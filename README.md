# Random Walk SDL (C++ / SDL3)

A simple random walk visualization written in modern C++ using SDL3 and CMake.
The program renders multiple colored random walks that evolve over time while remaining constrained to the window bounds.

This project focuses on:
- Real-time rendering with SDL3
- Basic simulation logic (random walks)
- Performance-aware C++ design (pre-allocation, minimal per-frame work)
- Clean build structure using CMake

---

## Demo Behavior

- Each walk starts at the center of the screen
- Every frame, new line segments are generated at random angles
- Lines are clamped to the window bounds to prevent out-of-range drawing
- Multiple walks are rendered simultaneously using different colors

---

## Project Structure

Random_Walk_SDL/
├── CMakeLists.txt
├── build/                  (CMake build artifacts, generated)
│   └── CMakeFiles/
│       └── Random_Walk_SDL.dir/
│           └── src/
│               ├── main.cpp.o
│               └── main.cpp.o.d
├── src/
│   ├── main.cpp             Application entry point
│   └── snail.bmp            Optional test asset
└── README.md

Note: The build/ directory is generated by CMake and should not be edited manually.

---

## Requirements

- C++20-compatible compiler
  - GCC 12+, Clang 15+, or MSVC 2022+
- SDL3
- CMake 3.20+
- Linux tested; macOS and Windows should work with proper SDL setup

---

## Building the Project

From the project root:

mkdir -p build
cd build
cmake ..
cmake --build .

---

## Running

From inside the build directory:

./Random_Walk_SDL

(The executable name may vary depending on your CMakeLists.txt.)

---

## Controls

Q — Quit the application

---

## Implementation Notes

### Random Walk Logic

Each walk stores its history as a vector of (x, y) coordinate pairs.
New points are generated using trigonometry:

x = prev_x + radius * cos(theta)
y = prev_y + radius * sin(theta)

Coordinates are clamped using std::clamp to prevent drawing outside the window bounds.

---

### Performance Considerations

- Vectors reserve memory up front to avoid unnecessary reallocations
- Walk objects are created once and updated incrementally
- Rendering is performed per frame without rebuilding simulation state
- Avoids recomputing full walks each frame

---

### Known Improvements / TODO

- Replace std::rand() with std::mt19937 for higher-quality randomness
- Move delay and frame timing logic into the main loop
- Add configurable step count and step radius
- Optional wrap-around or edge-reflection behavior
- Persist trails without clearing the screen every frame

---

## Why This Project?

This project was built as a hands-on exploration of:
- SDL3 rendering fundamentals
- Real-time update loops
- Simple simulation constraints
- Writing maintainable, performance-conscious C++

It serves as a foundation for more advanced work such as:
- Particle systems
- Procedural art
- Physics simulations
- Game engine subsystems

---

## License

MIT License (or add your preferred license here)
